/**
 * Vulnerability Scanner API Routes
 * Handles code security analysis and vulnerability detection
 */

import { Router, type Request, type Response } from 'express';
import { z } from 'zod';
import type { IStorage } from '../storage';
import { generateMelody, getAIClient } from '../services/grok';

export function createVulnerabilityRoutes(storage: IStorage) {
  const router = Router();

  /**
   * POST /api/vulnerability/scan
   * Scan code for security vulnerabilities
   */
  router.post('/scan', async (req: Request, res: Response) => {
    try {
      if (!req.userId) {
        return res.status(401).json({ error: 'Authentication required' });
      }

      const schema = z.object({
        code: z.string().min(1).max(50000),
        language: z.enum(['javascript', 'typescript', 'python', 'java', 'csharp', 'php', 'go']).default('javascript'),
      });

      const parsed = schema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ 
          error: 'Invalid input', 
          details: parsed.error.errors 
        });
      }

      const { code, language } = parsed.data;
      const startTime = Date.now();

      // Perform vulnerability scan
      const scanResult = await scanCodeForVulnerabilities(code, language);

      // Save scan result to storage
      await storage.createVulnerabilityScan(req.userId, {
        code: code.substring(0, 1000), // Store only first 1000 chars for privacy
        language,
        result: scanResult,
        scannedAt: new Date(),
        scanDuration: Date.now() - startTime,
      });

      res.json({
        ...scanResult,
        scannedAt: new Date().toISOString(),
        scanDuration: Date.now() - startTime,
      });
    } catch (error) {
      console.error('Vulnerability scan error:', error);
      res.status(500).json({ error: 'Failed to scan code' });
    }
  });

  /**
   * GET /api/vulnerability/history
   * Get user's scan history
   */
  router.get('/history', async (req: Request, res: Response) => {
    try {
      if (!req.userId) {
        return res.status(401).json({ error: 'Authentication required' });
      }

      const limit = parseInt(req.query.limit as string) || 10;
      const offset = parseInt(req.query.offset as string) || 0;

      const scans = await storage.getUserVulnerabilityScans(req.userId, limit, offset);

      res.json({ scans });
    } catch (error) {
      console.error('Get scan history error:', error);
      res.status(500).json({ error: 'Failed to fetch scan history' });
    }
  });

  /**
   * GET /api/vulnerability/stats
   * Get user's vulnerability scan statistics
   */
  router.get('/stats', async (req: Request, res: Response) => {
    try {
      if (!req.userId) {
        return res.status(401).json({ error: 'Authentication required' });
      }

      const stats = await calculateVulnerabilityStats(req.userId, storage);

      res.json(stats);
    } catch (error) {
      console.error('Get vulnerability stats error:', error);
      res.status(500).json({ error: 'Failed to fetch stats' });
    }
  });

  return router;
}

// Helper functions

async function scanCodeForVulnerabilities(code: string, language: string) {
  const issues = [];
  const lines = code.split('\n');

  // Define vulnerability patterns
  const patterns = [
    {
      id: 'eval-usage',
      severity: 'critical' as const,
      type: 'Code Injection',
      title: 'Use of eval() function',
      description: 'Using eval() can execute arbitrary code and is a major security risk.',
      pattern: /eval\s*\(/gi,
      suggestion: 'Avoid using eval(). Use safer alternatives like JSON.parse() for JSON data or proper function calls.',
      cwe: 'CWE-94',
      owasp: 'A03:2021 - Injection',
    },
    {
      id: 'sql-injection',
      severity: 'critical' as const,
      type: 'SQL Injection',
      title: 'Potential SQL injection vulnerability',
      description: 'Direct string concatenation in SQL queries can lead to SQL injection attacks.',
      pattern: /(SELECT|INSERT|UPDATE|DELETE).*\$\{.*\}/gi,
      suggestion: 'Use parameterized queries or prepared statements to prevent SQL injection.',
      cwe: 'CWE-89',
      owasp: 'A03:2021 - Injection',
    },
    {
      id: 'hardcoded-password',
      severity: 'critical' as const,
      type: 'Security Misconfiguration',
      title: 'Hardcoded password or secret',
      description: 'Hardcoded credentials in source code pose a significant security risk.',
      pattern: /(password|secret|key|token)\s*[:=]\s*['"`][^'"`]+['"`]/gi,
      suggestion: 'Store credentials in environment variables or secure configuration files.',
      cwe: 'CWE-798',
      owasp: 'A05:2021 - Security Misconfiguration',
    },
    {
      id: 'xss-vulnerability',
      severity: 'high' as const,
      type: 'Cross-Site Scripting',
      title: 'Potential XSS vulnerability',
      description: 'Direct insertion of user input into HTML without sanitization can lead to XSS attacks.',
      pattern: /(innerHTML|outerHTML)\s*=\s*.*\$\{.*\}/gi,
      suggestion: 'Use textContent instead of innerHTML, or properly sanitize user input.',
      cwe: 'CWE-79',
      owasp: 'A03:2021 - Injection',
    },
    {
      id: 'path-traversal',
      severity: 'high' as const,
      type: 'Path Traversal',
      title: 'Potential path traversal vulnerability',
      description: 'Using user input directly in file paths can allow access to unauthorized files.',
      pattern: /(fs\.|readFile|writeFile).*\$\{.*\}/gi,
      suggestion: 'Validate and sanitize file paths, use path.join() and check if path is within allowed directories.',
      cwe: 'CWE-22',
      owasp: 'A01:2021 - Broken Access Control',
    },
    {
      id: 'weak-crypto',
      severity: 'medium' as const,
      type: 'Cryptographic Issues',
      title: 'Weak cryptographic algorithm',
      description: 'Using outdated or weak cryptographic algorithms.',
      pattern: /(md5|sha1)\s*\(/gi,
      suggestion: 'Use stronger algorithms like SHA-256 or bcrypt for password hashing.',
      cwe: 'CWE-327',
      owasp: 'A02:2021 - Cryptographic Failures',
    },
    {
      id: 'debug-code',
      severity: 'low' as const,
      type: 'Information Disclosure',
      title: 'Debug code in production',
      description: 'Debug statements can leak sensitive information in production.',
      pattern: /(console\.log|console\.debug|console\.info)/gi,
      suggestion: 'Remove debug statements before deploying to production.',
      cwe: 'CWE-200',
      owasp: 'A05:2021 - Security Misconfiguration',
    },
    {
      id: 'insecure-random',
      severity: 'medium' as const,
      type: 'Cryptographic Issues',
      title: 'Insecure random number generation',
      description: 'Using Math.random() for security-sensitive purposes is not cryptographically secure.',
      pattern: /Math\.random\(\)/gi,
      suggestion: 'Use crypto.randomBytes() or window.crypto.getRandomValues() for secure random numbers.',
      cwe: 'CWE-338',
      owasp: 'A02:2021 - Cryptographic Failures',
    },
  ];

  // Scan for vulnerabilities
  lines.forEach((line, lineIndex) => {
    patterns.forEach(pattern => {
      const matches = line.match(pattern.pattern);
      if (matches) {
        issues.push({
          id: `${pattern.id}-${lineIndex}`,
          severity: pattern.severity,
          type: pattern.type,
          title: pattern.title,
          description: pattern.description,
          line: lineIndex + 1,
          column: line.indexOf(matches[0]) + 1,
          code: line.trim(),
          suggestion: pattern.suggestion,
          cwe: pattern.cwe,
          owasp: pattern.owasp,
        });
      }
    });
  });

  // Use AI to detect additional vulnerabilities
  try {
    const aiIssues = await detectVulnerabilitiesWithAI(code, language);
    issues.push(...aiIssues);
  } catch (error) {
    console.error('AI vulnerability detection failed:', error);
  }

  // Remove duplicates and sort by severity
  const uniqueIssues = issues.filter((issue, index, self) => 
    index === self.findIndex((i) => i.line === issue.line && i.type === issue.type)
  );

  uniqueIssues.sort((a, b) => {
    const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
    return severityOrder[b.severity] - severityOrder[a.severity];
  });

  // Calculate summary
  const summary = {
    total: uniqueIssues.length,
    critical: uniqueIssues.filter(i => i.severity === 'critical').length,
    high: uniqueIssues.filter(i => i.severity === 'high').length,
    medium: uniqueIssues.filter(i => i.severity === 'medium').length,
    low: uniqueIssues.filter(i => i.severity === 'low').length,
  };

  return {
    issues: uniqueIssues,
    summary,
  };
}

async function detectVulnerabilitiesWithAI(code: string, language: string) {
  try {
    const aiClient = getAIClient();
    if (!aiClient) {
      return [];
    }

    const prompt = `Analyze the following ${language} code for security vulnerabilities. 
Focus on common issues like injection attacks, authentication bypasses, data exposure, and cryptographic weaknesses.

Code to analyze:
\`\`\`${language}
${code}
\`\`\`

Return ONLY a JSON array of vulnerability objects with this structure:
[
  {
    "id": "unique-id",
    "severity": "critical|high|medium|low",
    "type": "vulnerability-type",
    "title": "brief title",
    "description": "detailed description",
    "line": line_number,
    "column": column_number,
    "code": "relevant_code_snippet",
    "suggestion": "how to fix",
    "cwe": "CWE-number",
    "owasp": "OWASP reference"
  }
]

If no vulnerabilities are found, return an empty array []`;

    const completion = await aiClient.chat.completions.create({
      model: 'gpt-4',
      messages: [{ role: 'user', content: prompt }],
      response_format: { type: 'json_object' },
      temperature: 0.3,
      max_tokens: 2000,
    });

    const content = completion.choices[0]?.message?.content || '[]';
    let aiIssues = [];
    
    try {
      aiIssues = JSON.parse(content);
    } catch (parseError) {
      console.error('Failed to parse AI response:', parseError);
      return [];
    }

    // Validate and filter AI results
    return aiIssues.filter(issue => 
      issue.id && 
      issue.severity && 
      issue.type && 
      issue.title && 
      issue.description &&
      typeof issue.line === 'number'
    );
  } catch (error) {
    console.error('AI vulnerability detection error:', error);
    return [];
  }
}

async function calculateVulnerabilityStats(userId: string, storage: IStorage) {
  try {
    const scans = await storage.getUserVulnerabilityScans(userId, 1000, 0);
    
    const totalScans = scans.length;
    const totalIssues = scans.reduce((sum, scan) => sum + (scan.result?.summary?.total || 0), 0);
    const criticalIssues = scans.reduce((sum, scan) => sum + (scan.result?.summary?.critical || 0), 0);
    const highIssues = scans.reduce((sum, scan) => sum + (scan.result?.summary?.high || 0), 0);
    const mediumIssues = scans.reduce((sum, scan) => sum + (scan.result?.summary?.medium || 0), 0);
    const lowIssues = scans.reduce((sum, scan) => sum + (scan.result?.summary?.low || 0), 0);
    
    // Calculate most common vulnerability types
    const typeCounts = {};
    scans.forEach(scan => {
      if (scan.result?.issues) {
        scan.result.issues.forEach(issue => {
          typeCounts[issue.type] = (typeCounts[issue.type] || 0) + 1;
        });
      }
    });
    
    const mostCommonType = Object.entries(typeCounts)
      .sort(([, a], [, b]) => b - a)[0]?.[0] || 'None';

    return {
      totalScans,
      totalIssues,
      criticalIssues,
      highIssues,
      mediumIssues,
      lowIssues,
      mostCommonType,
      averageIssuesPerScan: totalScans > 0 ? Math.round(totalIssues / totalScans) : 0,
    };
  } catch (error) {
    console.error('Calculate vulnerability stats error:', error);
    return {
      totalScans: 0,
      totalIssues: 0,
      criticalIssues: 0,
      highIssues: 0,
      mediumIssues: 0,
      lowIssues: 0,
      mostCommonType: 'None',
      averageIssuesPerScan: 0,
    };
  }
}
